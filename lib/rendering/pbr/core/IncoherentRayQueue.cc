// Copyright 2023 DreamWorks Animation LLC
// SPDX-License-Identifier: Apache-2.0

//
//
#include "IncoherentRayQueue.h"
#include "PbrTLState.h"
#include <moonray/rendering/pbr/core/RayState.h>
#include <moonray/rendering/pbr/handlers/RayHandlers.h>
#include <moonray/rendering/shading/Types.h>

#include <scene_rdl2/common/math/BBox.h>
#include <scene_rdl2/common/math/MathUtil.h>
#include <scene_rdl2/common/math/Vec2.h>
#include <scene_rdl2/common/math/Vec3.h>

namespace moonray {
namespace pbr {

namespace
{

//
// This table was generated by calling the reference version of computeDirSortKey
// on all directions over an octant (including applying a morton space filling
// curve to the results). The resultant 16-bit values are stored in a 16x16 table
// indexed by quantizing the x and z directional components of the incoming
// normalized direction.
//
// See /work/rd/raas/pics/mark/ray_sorting/RaySortingPolarMortonLookupTable.tga
// for visualizations.
//
// The code used to generated the directional lookup table looks like:
//
//     const uint32_t TABLE_SIZE = 16;
//     uint32_t table[TABLE_SIZE][TABLE_SIZE];
//
//     float scl, ofs;
//     scene_rdl2::math::getScaleOffset(0.f, float(TABLE_SIZE - 1), 0.f, 1.f, &scl, &ofs);
//
//     for (unsigned y = 0; y < TABLE_SIZE; ++y) {
//         float dy = float(y) * scl + ofs;
//         for (unsigned x = 0; x < TABLE_SIZE; ++x) {
//             float dx = float(x) * scl + ofs;
//             float len = length(scene_rdl2::math::Vec2f(dx, dy));
//
//             scene_rdl2::math::Vec3f dir;
//             if (len >= 1.f) {
//                 dir = normalize(scene_rdl2::math::Vec3f(dx, dy, 0.f));
//             } else {
//                 float dz = sqrtf(1.f - (dx * dx) - (dy * dy));
//                 dir = scene_rdl2::math::Vec3f(dx, dy, dz);
//             }
//
//             // see computeDirSortKey(const scene_rdl2::math::Vec3f &dir) below.
//             uint32_t dirSortKey = computeReferenceDirSortKey(dir);
//             table[y][x] = dirSortKey;
//         }
//     }
//
MAYBE_UNUSED static CACHE_ALIGN uint16_t gDirLookup[256] =
{
    0x0000, 0x0088, 0x0222, 0x0800, 0x088a, 0x0a2a, 0x200a, 0x20aa,
    0x228a, 0x2880, 0x2a28, 0x8028, 0x822a, 0x8888, 0xa020, 0xaaaa,
    0x55dd, 0x15ff, 0x12c5, 0x0d18, 0x0cb7, 0x0e80, 0x2164, 0x2315,
    0x23b0, 0x2986, 0x2b2a, 0x807c, 0x827b, 0x88da, 0xa067, 0xaaee,
    0x5777, 0x4790, 0x17fd, 0x197f, 0x1a47, 0x0fde, 0x2538, 0x2659,
    0x26bd, 0x2c8f, 0x2e82, 0x81d3, 0x83cc, 0x89e8, 0xa195, 0xabbb,
    0x5d55, 0x584d, 0x4c2a, 0x1dfd, 0x1e6a, 0x3142, 0x30cf, 0x3229,
    0x2d4c, 0x2dba, 0x2ef7, 0x84e5, 0x86bd, 0x8e18, 0xa4ac, 0xaeaa,
    0x5ddf, 0x59e2, 0x4f12, 0x4b3f, 0x1fff, 0x347b, 0x3357, 0x33b0,
    0x38c5, 0x3a30, 0x855c, 0x8742, 0x8d1a, 0x8f82, 0xa6d1, 0xaeee,
    0x5f7f, 0x5bd5, 0x5a8b, 0x6417, 0x612e, 0x3755, 0x3783, 0x3c1b,
    0x39ed, 0x3b8e, 0x90c7, 0x9291, 0x9888, 0xa54d, 0xad9d, 0xafba,
    0x755f, 0x7431, 0x706d, 0x659a, 0x6602, 0x62d6, 0x3d57, 0x3d8f,
    0x3e68, 0x915f, 0x9342, 0x9903, 0x9a65, 0xb0bc, 0xbaab, 0xaffe,
    0x75ff, 0x7640, 0x730c, 0x677c, 0x66e5, 0x694e, 0x68da, 0x3f77,
    0x9511, 0x94e5, 0x968d, 0x99da, 0xb114, 0xb90a, 0xbaef, 0xbabf,
    0x77df, 0x76e5, 0x73e8, 0x7819, 0x6d90, 0x6cb8, 0x6b3d, 0xc044,
    0x95df, 0x973e, 0x9c79, 0x9e96, 0xb35d, 0xbbeb, 0xbbba, 0xbaff,
    0x7dd5, 0x7cd3, 0x79da, 0x78ef, 0x6f65, 0x6edb, 0xc40a, 0xc1b0,
    0xc26b, 0x9d77, 0x9f37, 0xb4dd, 0xbeea, 0xbeae, 0xbbfb, 0xbbea,
    0x7f7d, 0x7e7f, 0x7bd7, 0x7ba2, 0xd009, 0xc592, 0xc617, 0xc3d8,
    0xc92c, 0xca62, 0xb5d5, 0xbdc8, 0xbfab, 0xbeee, 0xbebb, 0xbbff,
    0xd57d, 0xd529, 0xd486, 0xd1b0, 0xd217, 0xc7c4, 0xcc56, 0xcc8f,
    0xcbc3, 0xe188, 0xe89d, 0xbfff, 0xbfea, 0xbfae, 0xbefa, 0xbebf,
    0xd77f, 0xd72e, 0xd699, 0xd3e8, 0xd84f, 0xcddd, 0xcf30, 0xe441,
    0xe608, 0xebbf, 0xeafe, 0xeabf, 0xbfff, 0xbfeb, 0xbfaf, 0xbefb,
    0xdddd, 0xdd8f, 0xdcbd, 0xdb4d, 0xdad7, 0xf018, 0xe5e9, 0xec5f,
    0xeebe, 0xebfb, 0xebbb, 0xeafb, 0xeabe, 0xbfff, 0xbfeb, 0xbfba,
    0xf575, 0xf532, 0xf4c0, 0xf1f9, 0xf384, 0xf8c8, 0xeffe, 0xefba,
    0xeeef, 0xeeae, 0xebee, 0xebaf, 0xeafa, 0xeabe, 0xbfff, 0xbfee,
    0xffff, 0xffbb, 0xfeee, 0xfbff, 0xfbbb, 0xfaef, 0xfaab, 0xefea,
    0xefaa, 0xeebf, 0xeeaa, 0xebea, 0xebae, 0xeaef, 0xeabb, 0xbfff,
};

__forceinline uint32_t
MAYBE_UNUSED mortonEncode2D(uint32_t x, uint32_t y)
{
    MNRY_ASSERT(x <= 0xffff);
    MNRY_ASSERT(y <= 0xffff);

    uint32_t res = (y << 16) | x;
    uint32_t tmp;

    tmp = (res ^ (res >> 8)) & 0x0000ff00;    res = res ^ tmp ^ (tmp << 8);
    tmp = (res ^ (res >> 4)) & 0x00f000f0;    res = res ^ tmp ^ (tmp << 4);
    tmp = (res ^ (res >> 2)) & 0x0c0c0c0c;    res = res ^ tmp ^ (tmp << 2);
    tmp = (res ^ (res >> 1)) & 0x22222222;    res = res ^ tmp ^ (tmp << 1);

    return res;
}

__forceinline uint32_t
MAYBE_UNUSED getOctant(const scene_rdl2::math::Vec3f &dir)
{
    uint32_t negX = dir.x < 0.f ? 1 : 0;
    uint32_t negY = dir.y < 0.f ? 2 : 0;
    uint32_t negZ = dir.z < 0.f ? 4 : 0;
    return negX | negY | negZ;
}

__forceinline uint32_t
MAYBE_UNUSED computeDirSortKey(const scene_rdl2::math::Vec3f &dir)
{
    MNRY_ASSERT(isNormalized(dir));

#if 0

    // Reference implementation for comparison purposes.
    scene_rdl2::math::Vec3f absDir = abs(dir);
    float theta = acosf(absDir.y);
    float phi = atan2f(absDir.z, absDir.x);

    scene_rdl2::math::Vec2f spherical(phi * scene_rdl2::math::sOneOverTwoPi, theta * scene_rdl2::math::sOneOverPi);

    // This will be the case since we're confining dir to a single quadrant by
    // taking the absolute value of each component.
    MNRY_ASSERT(spherical.x >= 0.f && spherical.x <= 0.25000001f);
    MNRY_ASSERT(spherical.y >= 0.f && spherical.y <= 0.5000001f);

    uint32_t dx = uint32_t(spherical.x * 1023.999f);
    uint32_t dy = uint32_t(spherical.y * 511.999f);

    MNRY_ASSERT(dx <= 255);
    MNRY_ASSERT(dy <= 255);

    uint32_t dirSortKey = mortonEncode2D(dy, dx);

    MNRY_ASSERT(dirSortKey <= 0xffff);

    return dirSortKey;

#else

    // Optimized version. This doesn't produce identical sort keys to the
    // reference code but from a sorting standpoint it should perform just as
    // well and be significantly cheaper to compute.
    uint32_t dx = uint32_t(fabsf(dir.x) * 15.9999f);
    uint32_t dz = uint32_t(fabsf(dir.z) * 15.9999f);

    return uint32_t(gDirLookup[(dz << 4) + dx]);

#endif
}

__forceinline uint32_t
MAYBE_UNUSED computePosSortKey(const scene_rdl2::math::Vec3f &p)
{
    MNRY_ASSERT(p.x >= 0.f && p.x < 256.f);
    uint32_t px = uint32_t(p.x) >> 2;
    MNRY_ASSERT(px < 64);

//    MNRY_ASSERT(p.y >= 0.f && p.y < 256.f);
//    uint32_t py = uint32_t(p.y) >> 2;
//    MNRY_ASSERT(py < 64);

    MNRY_ASSERT(p.z >= 0.f && p.z < 256.f);
    uint32_t pz = uint32_t(p.z) >> 2;
    MNRY_ASSERT(pz < 64);

    uint32_t morton = mortonEncode2D(px, pz);

    MNRY_ASSERT(morton <= 4095);

    return morton;
}

}   // End of anon namespace.

scene_rdl2::math::Vec3f IncoherentRayQueue::sPositionScale;
scene_rdl2::math::Vec3f IncoherentRayQueue::sPositionOffset;

IncoherentRayQueue::IncoherentRayQueue() :
    mEntries(nullptr)
{
}

IncoherentRayQueue::~IncoherentRayQueue()
{
    scene_rdl2::util::alignedFreeArray(mEntries);
}

void
IncoherentRayQueue::init(unsigned queueSize)
{
    MNRY_ASSERT(mEntries == nullptr);

    mEntries = scene_rdl2::util::alignedMallocArray<EntryType>(queueSize, CACHE_LINE_SIZE);

    BaseIncoherentRayQueue::init(queueSize, mEntries);

    uint32_t rayHandlerFlags = 0;

#ifdef RAY_SORTING
    rayHandlerFlags |= RAYHANDLER_SORTED_RAYSTATES;
#endif

    setHandler(rayBundleHandler, (void *)((uint64_t)rayHandlerFlags));
}

void
IncoherentRayQueue::addEntries(mcrt_common::ThreadLocalState *tls,
                               unsigned numEntries, RayState **entries,
                               scene_rdl2::alloc::Arena *arena)
{
    // Convert all incoming RayStates into SortedRayStates (in place) to make
    // room for sort keys.
    WrappedRayState *wrappedRs = reinterpret_cast<WrappedRayState *>(entries);

#ifdef RAY_SORTING

    EXCL_ACCUMULATOR_PROFILE(tls, EXCL_ACCUM_RAY_SORT_KEY_GEN);

    RayState *baseRayState = indexToRayState(0);
    for (unsigned i = 0; i < numEntries; ++i) {

        //
        // Compute sort key...
        //

        RayState *rs = entries[i];
        wrappedRs[i].mSortedRs.mRsIdx = shading::RayStateIndex(rs - baseRayState);

        const scene_rdl2::math::Vec3f &pos = rs->mRay.getOrigin();
        const scene_rdl2::math::Vec3f &dir = rs->mRay.getDirection();

        uint32_t octant = getOctant(dir) << 28;
        uint32_t p = computePosSortKey(pos * sPositionScale + sPositionOffset) << 16;
        uint32_t d = computeDirSortKey(dir) << 0;

        MNRY_ASSERT((octant & p) == 0);
        MNRY_ASSERT((octant & d) == 0);
        MNRY_ASSERT((p & d) == 0);

        //
        // Octant is located in the up most bits since that's the primary criteria
        // the embree streaming implementation uses internally to sort rays.
        // Next we have a choice between position and direction. Position seems
        // to be the most logical choice since a BVH is a spatial data structure
        // after all. Direction then goes in the lower bits. The overall
        // structure looks like:
        //
        //  bit  31     free
        //  bits 28-30  octant
        //  bits 16-27  position (morton xz)
        //  bits  0-15  direction (morton polar)
        //
        wrappedRs[i].mSortedRs.mSortKey = octant | p | d;
    }

#endif

    BaseIncoherentRayQueue::addEntries(tls, numEntries, wrappedRs, arena);
}

// Split the world extents into 256 blocks along each axis. Note that these likely aren't
// perfectly cubic in shape.
void
IncoherentRayQueue::setBounds(const scene_rdl2::math::BBox3f &bbox)
{
    MNRY_ASSERT(bbox.lower.x <= bbox.upper.x);
    MNRY_ASSERT(bbox.lower.y <= bbox.upper.y);
    MNRY_ASSERT(bbox.lower.z <= bbox.upper.z);

    scene_rdl2::math::Vec3f extents = bbox.upper - bbox.lower;
    float maxExtent = reduce_max(extents);
    float padding = std::max(maxExtent * 0.05f, 0.001f);
    float halfExt = maxExtent * 0.5f + padding;
    scene_rdl2::math::Vec3f midpoint = center(bbox);

    scene_rdl2::math::getScaleOffset(midpoint.x - halfExt, midpoint.x + halfExt, 0.f, 255.99f,
                         &sPositionScale.x, &sPositionOffset.x);
    scene_rdl2::math::getScaleOffset(midpoint.y - halfExt, midpoint.y + halfExt, 0.f, 255.99f,
                         &sPositionScale.y, &sPositionOffset.y);
    scene_rdl2::math::getScaleOffset(midpoint.z - halfExt, midpoint.z + halfExt, 0.f, 255.99f,
                         &sPositionScale.z, &sPositionOffset.z);

    //std::cout << "bounds = " << bbox << std::endl;
}

} // namespace pbr
} // namespace moonray

